Observability
Наблюдаемость системы – это мера простоты определения ее внутреннего состояния по наблюдаемым результатам. Система считается наблюдаемой, если можно быстро и последовательно получать ответы на все новые вопросы о ней с минимальными предварительными знаниями, без необходимости внедряться в существующий код или писать новый.

https://habr.com/ru/articles/723248/

В прошлой статье мы с помощью Prometheus AlertManager настроили правила, чтобы отправлять уведомления через Slack при срабатывании алертов. И хотя алерты и уведомления — это удобно и полезно, сами по себе метрики не до конца объясняют проблему. Они просто показывают, что значения одного экземпляра вышли за установленные лимиты, но в распределённых системах метрики не могут отследить запрос, который проходит через несколько компонентов. С распространением микросервисов системы усложняются, поэтому мы должны проследить весь путь запроса, чтобы понять, что пошло не так. Для этого можно использовать распределённую трассировку, которая записывает действия, выполняемые в связи с запросом, и дает контекст, который мы не найдем в метриках и логах.

Трейс — это коллекция спанов, где спан — это запись операции, выполняемой одним сервисом. У него есть имя, время начала, продолжительность, контекст и дополнительные метаданные. С помощью трейсов мы отслеживаем путь запроса по всем сервисам распределённой системы.
Анализируя данные трейсов, можно увидеть поведение запроса, найти проблемы и узкие места, а также определить потенциальные области для улучшения и оптимизации. Для создания спанов мы используем инструментирование с помощью API или SDK, которые предоставляются клиентской библиотекой трассировщика.

Инструментирование

Приложение можно инструментировать вручную, вставив начало и конец спанов во фрагменты кода, которые дают вам полезную информацию. Некоторые фреймворки предлагают автоматическое инструментирование, с которым не придется тратить время и силы и менять базу кода.
Автоматическое и ручное инструментирование можно комбинировать. Например, первое можно использовать для экономии времени, а второе — для случаев, когда требуется больше контроля.
Существует много решений для трассировки со своими клиентскими библиотеками для инструментирования на разных языках. Например:

Распространение контекста

Прежде чем создавать кастомные спаны, нужно решить, как проводить корреляцию между спанами. Для корреляции спаны должны обмениваться информацией через контекст. Контекст содержит информацию, которую можно передавать между функциями в одном процессе (распространение внутри процесса) и в разных (распространение между процессами).


Распространение — это механизм, с помощью которого контекст перемещается между разными сервисами и процессами.


Вы уже видели оба примера, но знаете ли вы, как спаны из трех сервисов попали в один трейс? Или как спаны из разных функций в одном сервисе могут становиться друг для друга родительскими и дочерними? Ответ — распространение контекста.
Для распространения контекста используется много протоколов. Самые популярные из них:
W3C Trace-Context HTTP Propagator
B3 Zipkin Propagator

OpenTelemetry может использовать оба протокола, но в некоторых случаях приходится выбирать. Например, для распространения контекста в Istio нужно использовать заголовки B3.
